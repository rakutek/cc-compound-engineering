---
name: workflows:work
description: 品質を維持しながら効率的に作業プランを実行し、機能を完成させる
argument-hint: "[プランファイル、仕様書、またはTodoファイルのパス]"
---

# 作業プラン実行コマンド

品質を維持しながら効率的に作業プランを実行し、機能を完成させます。

## はじめに

このコマンドは作業ドキュメント（プラン、仕様書、またはTodoファイル）を受け取り、体系的に実行します。焦点は、要件を素早く理解し、既存のパターンに従い、全体を通して品質を維持することで**完全な機能を出荷すること**です。

## 入力ドキュメント

<input_document> #$ARGUMENTS </input_document>

## 実行ワークフロー

### フェーズ1：クイックスタート

1. **プランを読んで明確化**

   - 作業ドキュメントを完全に読む
   - プランで提供されている参照やリンクをレビュー
   - 不明確または曖昧な点があれば、今すぐ明確化の質問をする
   - 進行前にユーザーの承認を得る
   - **これをスキップしない** - 今質問する方が間違ったものを作るより良い

2. **環境のセットアップ**

   作業スタイルを選択：

   **オプションA：現在のブランチでライブ作業**
   ```bash
   git checkout main && git pull origin main
   git checkout -b feature-branch-name
   ```

   **オプションB：worktreeを使った並列作業（並列開発に推奨）**
   ```bash
   # まずユーザーに質問：「worktreeで並列作業しますか、現在のブランチで作業しますか？」
   # worktreeの場合：
   skill: git-worktree
   # スキルがmainから分離したworktreeに新しいブランチを作成
   ```

   **推奨**：以下の場合にworktreeを使用：
   - 複数の機能を同時に作業したい
   - 実験中はmainをクリーンに保ちたい
   - ブランチ間を頻繁に切り替える予定

   以下の場合はライブブランチを使用：
   - 単一の機能に取り組んでいる
   - メインリポジトリにとどまりたい

3. **Todoリストを作成**
   - TodoWriteを使用してプランを実行可能なタスクに分解
   - タスク間の依存関係を含める
   - 最初に行うべきことに基づいて優先順位付け
   - テストと品質チェックタスクを含める
   - タスクを具体的で完了可能に保つ

### フェーズ2：実行

1. **タスク実行ループ**

   優先順位順に各タスクについて：

   ```
   while (タスクが残っている):
     - TodoWriteでタスクをin_progressにマーク
     - プランから参照されているファイルを読む
     - コードベースで類似パターンを探す
     - 既存の規約に従って実装
     - 新機能のテストを書く
     - 変更後にテストを実行
     - タスクをcompletedにマーク
   ```

2. **既存パターンに従う**

   - プランは類似コードを参照しているはず - まずそれらのファイルを読む
   - 命名規約を正確にマッチ
   - 可能な場合は既存コンポーネントを再利用
   - プロジェクトのコーディング標準に従う（CLAUDE.mdを参照）
   - 迷ったら類似実装をgrepで検索

3. **継続的にテスト**

   - 重要な変更のたびに関連テストを実行
   - 最後までテストを待たない
   - 失敗はすぐに修正
   - 新機能には新しいテストを追加

4. **Figmaデザイン同期**（該当する場合）

   Figmaデザインを伴うUI作業の場合：

   - デザイン仕様に従ってコンポーネントを実装
   - figma-design-syncエージェントを繰り返し使用して比較
   - 特定された視覚的な差異を修正
   - 実装がデザインに一致するまで繰り返す

5. **進捗を追跡**
   - タスク完了に応じてTodoWriteを更新
   - ブロッカーや予期しない発見をメモ
   - スコープが拡大した場合は新しいタスクを作成
   - 主要なマイルストーンをユーザーに通知

### フェーズ3：品質チェック

1. **コア品質チェックを実行**

   提出前に常に実行：

   ```bash
   # フルテストスイートを実行
   bin/rails test

   # リンティングを実行（CLAUDE.mdに従って）
   # originにプッシュする前にlintエージェントを使用
   Task lint: "リンティングとコード品質チェックを実行"
   ```

2. **レビュアーエージェントの検討**（オプション）

   複雑、リスクの高い、または大きな変更に使用：

   - **kieran-code-reviewer**：コーディング規約を確認
   - **performance-oracle**：パフォーマンス問題をチェック
   - **security-sentinel**：セキュリティ脆弱性をスキャン

   Taskツールでレビュアーを並列実行：

   ```
   Task(kieran-code-reviewer): "コーディング規約をチェック"
   ```

   発見事項をユーザーに提示し、重大な問題に対処。

3. **最終検証**
   - すべてのTodoWriteタスクがcompletedにマーク
   - すべてのテストがパス
   - リンティングがパス
   - コードが既存パターンに従っている
   - Figmaデザインに一致（該当する場合）
   - コンソールエラーや警告がない

### フェーズ4：出荷

1. **コミットを作成**

   ```bash
   git add .
   git status  # コミットされる内容をレビュー
   git diff --staged  # 変更をチェック

   # 従来のフォーマットでコミット
   git commit -m "$(cat <<'EOF'
   feat(scope): 何を、なぜの説明

   必要に応じて簡潔な説明。

   🤖 Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"
   ```

2. **UI変更のスクリーンショットをキャプチャしてアップロード**（UI作業では必須）

   **すべての**デザイン変更、新しいビュー、またはUI修正では、スクリーンショットをキャプチャしてアップロードする必要があります：

   **ステップ1：devサーバーを起動**（実行していない場合）
   ```bash
   bin/dev  # バックグラウンドで実行
   ```

   **ステップ2：agent-browserでスクリーンショットをキャプチャ**
   - `agent-browser open <url>`で影響を受けるページに移動
   - `agent-browser snapshot -i`でページ状態を確認
   - `agent-browser screenshot`で画像をキャプチャ

   **キャプチャする内容：**
   - **新しい画面**：新しいUIのスクリーンショット
   - **変更された画面**：変更前と変更後のスクリーンショット
   - **デザイン実装**：Figmaデザインとの一致を示すスクリーンショット

   **重要**：アップロードされた画像URLは常にPR説明に含めること。これはレビュアーに視覚的コンテキストを提供し、変更を文書化します。

3. **プルリクエストを作成**

   ```bash
   git push -u origin feature-branch-name

   gh pr create --title "Feature: [説明]" --body "$(cat <<'EOF'
   ## サマリー
   - 何を構築したか
   - なぜ必要だったか
   - 行った重要な決定

   ## テスト
   - 追加/変更したテスト
   - 実行した手動テスト

   ## Before / After スクリーンショット
   | Before | After |
   |--------|-------|
   | ![before](URL) | ![after](URL) |

   ## Figmaデザイン
   [該当する場合はリンク]

   🤖 Generated with [Claude Code](https://claude.com/claude-code)
   EOF
   )"
   ```

4. **ユーザーに通知**
   - 完了したことをサマリー
   - PRへのリンク
   - 必要なフォローアップ作業をメモ
   - 該当する場合は次のステップを提案

---

## 主要原則

### 速くスタートし、より速く実行

- 最初に一度明確化を得て、それから実行
- 完璧な理解を待たない - 質問して進む
- 目標は完璧なプロセスではなく**機能を完成させること**

### プランがガイド

- 作業ドキュメントは類似コードとパターンを参照すべき
- それらの参照をロードして従う
- 再発明しない - 既存のものに合わせる

### 進みながらテスト

- 最後ではなく各変更後にテストを実行
- 失敗はすぐに修正
- 継続的テストは大きなサプライズを防ぐ

### 品質は組み込み

- 既存パターンに従う
- 新しいコードにはテストを書く
- プッシュ前にリンティングを実行
- レビュアーエージェントは複雑/リスクの高い変更にのみ使用

### 完全な機能を出荷

- 次に進む前にすべてのタスクを完了にマーク
- 機能を80%完成で放置しない
- 出荷される完成した機能は、出荷されない完璧な機能に勝る

## 品質チェックリスト

PR作成前に確認：

- [ ] すべての明確化の質問を聞いて回答を得た
- [ ] すべてのTodoWriteタスクがcompletedにマーク
- [ ] テストがパス（`bin/rails test`を実行）
- [ ] リンティングがパス（lintエージェントを使用）
- [ ] コードが既存パターンに従っている
- [ ] Figmaデザインが実装に一致（該当する場合）
- [ ] Before/afterスクリーンショットをキャプチャしてアップロード（UI変更の場合）
- [ ] コミットメッセージが従来のフォーマットに従っている
- [ ] PR説明にサマリー、テストメモ、スクリーンショットが含まれている

## レビュアーエージェントを使用するタイミング

**デフォルトでは使用しない。** 以下の場合にのみレビュアーエージェントを使用：

- 多くのファイル（10+）に影響する大規模リファクタリング
- セキュリティに敏感な変更（認証、権限、データアクセス）
- パフォーマンスクリティカルなコードパス
- 複雑なアルゴリズムやビジネスロジック
- ユーザーが徹底的なレビューを明示的にリクエスト

ほとんどの機能では：テスト + リンティング + パターンに従う で十分。

## 避けるべき一般的な落とし穴

- **分析麻痺** - 考えすぎない、プランを読んで実行
- **明確化の質問をスキップ** - 間違ったものを作った後ではなく今質問
- **プラン参照を無視** - プランには理由があってリンクがある
- **最後にテスト** - 継続的にテストしないと後で苦しむ
- **TodoWriteを忘れる** - 進捗を追跡しないと何が完了したかわからなくなる
- **80%完了症候群** - 機能を完成させる、早めに次に行かない
- **単純な変更を過剰レビュー** - 複雑な作業のためにレビュアーエージェントを取っておく
