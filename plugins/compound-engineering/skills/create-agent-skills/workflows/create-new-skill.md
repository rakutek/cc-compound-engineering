# ワークフロー：新しいスキルを作成

<required_reading>
**今すぐこれらのリファレンスファイルを読む：**
1. references/recommended-structure.md
2. references/skill-structure.md
3. references/core-principles.md
4. references/use-xml-tags.md
</required_reading>

<process>
## ステップ1：適応的な要件収集

**ユーザーがコンテキストを提供した場合**（例：「Xのためのスキルを構築」）：
→ 述べられていること、推測できること、不明確なことを分析
→ 本当のギャップについてのみ質問にスキップ

**ユーザーがコンテキストなしでスキルを呼び出した場合：**
→ 何を構築したいか尋ねる

### AskUserQuestionの使用

実際のギャップに基づいて2〜4つのドメイン固有の質問をします。各質問は：
- 説明付きの具体的なオプションを持つ
- スコープ、複雑さ、出力、境界に焦点を当てる
- コンテキストから明らかなことは尋ねない

質問の例：
- 「このスキルはどの具体的な操作を処理すべきですか？」（ドメインに基づいたオプション付き）
- 「[関連事項]も処理すべきですか、それとも[コア事項]に集中すべきですか？」
- 「成功時にユーザーは何を見るべきですか？」

### 決定ゲート

最初の質問の後、尋ねます：
「構築を進める準備ができていますか、それとももっと質問してほしいですか？」

オプション：
1. **構築を進める** - 十分なコンテキストがある
2. **もっと質問する** - 明確にすべき詳細がある
3. **詳細を追加させて** - 追加のコンテキストを提供したい

## ステップ2：リサーチトリガー（外部APIの場合）

**外部サービスが検出された場合**、AskUserQuestionを使用して尋ねます：
「これは[サービス名] APIを含みます。構築前に現在のエンドポイントとパターンをリサーチしましょうか？」

オプション：
1. **はい、最初にリサーチ** - 正確な実装のために現在のドキュメントを取得
2. **いいえ、一般的なパターンで進める** - 特定のAPIリサーチなしで一般的なパターンを使用

リサーチが要求された場合：
- Context7 MCPを使用して現在のライブラリドキュメントを取得
- または最近のAPIドキュメント用にWebSearchを使用
- 2024-2025年のソースに焦点を当てる
- コンテンツ生成に使用するために発見を保存

## ステップ3：構造を決定

**シンプルスキル（単一ワークフロー、<200行）：**
→ すべてのコンテンツを含む単一のSKILL.mdファイル

**複雑なスキル（複数のワークフローまたはドメイン知識）：**
→ ルーターパターン：
```
skill-name/
├── SKILL.md（ルーター + 原則）
├── workflows/（手順 - 従う）
├── references/（知識 - 読む）
├── templates/（出力構造 - コピー + 入力）
└── scripts/（再利用可能コード - 実行）
```

ルーターパターンを好む要因：
- 複数の異なるユーザー意図（作成 vs デバッグ vs シップ）
- ワークフロー間で共有されるドメイン知識
- スキップしてはいけない重要な原則
- 時間とともに成長する可能性があるスキル

**templates/を検討する場合：**
- スキルが一貫した出力構造を生成（計画、仕様、レポート）
- 構造が創造的な生成よりも重要

**scripts/を検討する場合：**
- 呼び出し間で同じコードが実行される（デプロイ、セットアップ、API呼び出し）
- 毎回書き直すとエラーが起こりやすい操作

references/recommended-structure.mdを参照してテンプレートを確認。

## ステップ4：ディレクトリを作成

```bash
mkdir -p ~/.claude/skills/{skill-name}
# 複雑な場合：
mkdir -p ~/.claude/skills/{skill-name}/workflows
mkdir -p ~/.claude/skills/{skill-name}/references
# 必要に応じて：
mkdir -p ~/.claude/skills/{skill-name}/templates  # 出力構造用
mkdir -p ~/.claude/skills/{skill-name}/scripts    # 再利用可能コード用
```

## ステップ5：SKILL.mdを作成

**シンプルスキル：** 以下を含む完全なスキルファイルを作成：
- YAMLフロントマター（name、description）
- `<objective>`
- `<quick_start>`
- 純粋XMLのコンテンツセクション
- `<success_criteria>`

**複雑なスキル：** 以下を含むルーターを作成：
- YAMLフロントマター
- `<essential_principles>`（インライン、回避不可）
- `<intake>`（ユーザーに尋ねる質問）
- `<routing>`（回答をワークフローにマッピング）
- `<reference_index>`と`<workflows_index>`

## ステップ6：ワークフローを作成（複雑な場合）

各ワークフロー用：
```xml
<required_reading>
このワークフロー用に読み込むリファレンス
</required_reading>

<process>
ステップバイステップの手順
</process>

<success_criteria>
このワークフローが完了したことを知る方法
</success_criteria>
```

## ステップ7：リファレンスを作成（必要に応じて）

ドメイン知識：
- 複数のワークフローが必要とする可能性がある
- ワークフローに基づいて変化しない
- パターン、例、技術的詳細を含む

## ステップ8：構造を検証

チェック：
- [ ] YAMLフロントマターが有効
- [ ] nameがディレクトリと一致（lowercase-with-hyphens）
- [ ] descriptionが何をするかといつ使用するかを述べている（三人称）
- [ ] ボディ内にMarkdownの見出し（#）がない - XMLタグを使用
- [ ] 必須タグが存在：objective、quick_start、success_criteria
- [ ] 参照されているすべてのファイルが存在
- [ ] SKILL.mdが500行未満
- [ ] XMLタグが適切に閉じられている

## ステップ9：スラッシュコマンドを作成

```bash
cat > ~/.claude/commands/{skill-name}.md << 'EOF'
---
description: {簡単な説明}
argument-hint: [{引数のヒント}]
allowed-tools: Skill({skill-name})
---

$ARGUMENTSのために{skill-name}スキルを呼び出します
EOF
```

## ステップ10：テスト

スキルを呼び出して以下を観察：
- 正しい受付質問をしているか？
- 正しいワークフローを読み込んでいるか？
- ワークフローが正しいリファレンスを読み込んでいるか？
- 出力が期待と一致しているか？

仮定ではなく、実際の使用に基づいて反復します。
</process>

<success_criteria>
スキルは以下の場合に完了：
- [ ] 適切な質問で要件を収集
- [ ] 外部サービスが関係する場合はAPIリサーチ完了
- [ ] ディレクトリ構造が正しい
- [ ] SKILL.mdに有効なフロントマターがある
- [ ] 重要な原則がインライン（複雑なスキルの場合）
- [ ] 受付質問が正しいワークフローにルーティング
- [ ] すべてのワークフローにrequired_reading + process + success_criteriaを持つ
- [ ] リファレンスに再利用可能なドメイン知識が含まれる
- [ ] スラッシュコマンドが存在して機能する
- [ ] 実際の呼び出しでテスト済み
</success_criteria>
